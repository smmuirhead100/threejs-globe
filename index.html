<head>
  <style> body { margin: 0; } </style>

  <script type="importmap">{ "imports": {
    "three": "//unpkg.com/three/build/three.module.js",
    "three/addons/": "//unpkg.com/three/examples/jsm/"
  }}</script>
  <script type="module">
    import * as THREE from 'three';
    window.THREE = THREE;
  </script>

  <script src="//unpkg.com/three-globe" defer></script>
<!--  <script src="../../dist/three-globe.js" defer></script>-->
</head>

<body>
  <div id="globeViz"></div>
  <script src="https://apis.google.com/js/api.js"></script>
  <script type="module">
    import { TrackballControls } from 'three/addons/controls/TrackballControls.js';
    import { Vector3 } from 'three';
    import { CSS2DRenderer } from 'three/addons/renderers/CSS2DRenderer.js';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    let apiReady = false

    function handleClientLoad() {
        console.log("HERE")
        gapi.load('client:auth2', initClient);
    }

    function initClient() {
      console.log("GAPI START")
      gapi.client.init({
        apiKey: process.env.API_KEY,
        discoveryDocs: ["https://sheets.googleapis.com/$discovery/rest?version=v4"],
        // scope: 'https://www.googleapis.com/auth/spreadsheets.readonly'
      }).then(function () {
        console.log("LOGGED IN")
        // gapi.auth2.getAuthInstance().isSignedIn.listen(updateSignInStatus);
        // updateSignInStatus(gapi.auth2.getAuthInstance().isSignedIn.get());
        listMajors()
      }, function(error) {
        console.log("GAPI error")
        console.error(JSON.stringify(error, null, 2));
      });
      console.log("GAPI END")
    }
    

  function updateSignInStatus(isSignedIn) {
    if (isSignedIn && gapi.client.sheets) {
      console.log("SIGNED IN")
      apiReady = true;
      // listMajors()
    } else {
      console.log("NOT SIGNER IN")
      gapi.auth2.getAuthInstance().signIn();
    }
  }

  function gisLoaded() {
    console.log("GOT HERE")
        tokenClient = google.accounts.oauth2.initTokenClient({
          client_id: process.env.CLIENT_ID,
          scope: 'https://www.googleapis.com/auth/spreadsheets.readonly',
          callback: '', // defined later
        });
        gisInited = true;
        maybeEnableButtons();
      }


  function listMajors() {
    gapi.client.sheets.spreadsheets.values.get({
      spreadsheetId: '1b_1jISIYUwusGR95X4Bg5EqG5LHJQednazkXEr2aKHs',
      range: 'Sheet1!A2:D',
    }).then(function(response) {
      var range = response.result;
      if (range.values.length > 0) {
        console.log('Data retrieved from Sheets:', range.values);
      } else {
        console.log('No data found.');
      }
    }, function(response) {
      console.error('Failed to get data from Sheets:', response.result.error.message);
    });
  }

    const markerSvg = `<svg viewBox="-4 0 36 36">
      <path fill="currentColor" d="M14,0 C21.732,0 28,5.641 28,12.6 C28,23.963 14,36 14,36 C14,36 0,24.064 0,12.6 C0,5.641 6.268,0 14,0 Z"></path>
      <circle fill="black" cx="14" cy="14" r="7"></circle>
    </svg>`;

    const sleep = ms => new Promise(r => setTimeout(r, ms));

    const fetchSheetData = async () => {
      const { googleSheets, spreadsheetId } = await authenticateSheets();
      const range = 'Sheet1!B2:D10'; // Adjust the range to match your sheet structure

      const response = await googleSheets.spreadsheets.values.get({
        spreadsheetId,
        range,
      });

      return response.data.values;
    };

    // Gen random data
    const N = 20;
    let endLocations = [0, 0, 0, 0, 0, 0, 0, 0]

    let arcsData = []

    const Globe = new ThreeGlobe()
      .globeImageUrl('/world.jpg')
      // .bumpImageUrl('//unpkg.com/three-globe/example/img/earth-topology.png')
      // .arcsData(arcsData)
      // .arcColor('color')
      // .arcDashLength(0.4)
      // .arcStroke(.4)
      // .arcDashGap(4)
      // .arcDashInitialGap((d) => d.initialGap)
      // .arcDashAnimateTime(1000)

    //   const updateGlobeData = async () => {
    //   const sheetData = await fetchSheetData();
      
    //   // Filter out any rows that are empty or incomplete
    //   const validData = sheetData.filter(row => row.length === 3 && row.every(cell => cell !== ''));

    //   // Update endLocations with data from the sheet
    //   endLocations = validData.map(row => ({
    //     lat: parseFloat(row[2]),  // Assuming latitude is the third column
    //     lng: parseFloat(row[1]),  // Assuming longitude is the second column
    //   }));

    //   // Map arcsData from endLocations
    //   arcsData = endLocations.map(loc => ({
    //     startLat: 34.05,  // Latitude for Los Angeles
    //     startLng: -118.24,  // Longitude for Los Angeles
    //     endLat: loc.lat,
    //     endLng: loc.lng,
    //     color: 'white',
    //     initialGap: Math.random() * 60,  // Spread out over a minute
    //   }));
    //   Globe.arcsData(arcsData);
    //   Globe.arcDashInitialGap((d) => d.initialGap)

    // };

    function updateGlobeData() {
      gapi.client.sheets.spreadsheets.values.get({
        spreadsheetId: '1b_1jISIYUwusGR95X4Bg5EqG5LHJQednazkXEr2aKHs',
        range: 'Sheet1!B2:D1000',
      }).then(function(response) {
        const rows = response.result.values;
        if (rows.length) {
          console.log('Data retrieved from Sheets:', rows);
          const validData = rows.filter(row => row.length >= 3 && !isNaN(parseFloat(row[1])) && !isNaN(parseFloat(row[2])));

          console.log("valiud data", validData)
          
          endLocations = validData.map(row => ({
            lat: parseFloat(row[1]),  // Assuming latitude is the third column
            lng: parseFloat(row[2]),  // Assuming longitude is the second column
          }));

          arcsData = endLocations.map(loc => ({
            startLat: 34.05,  // Latitude for Los Angeles
            startLng: -118.24,  // Longitude for Los Angeles
            endLat: loc.lat,  
            endLng: -loc.lng,
            color: 'white',
            initialGap: Math.random() * (endLocations.length / 2),  // About one per half sec
          }));
          Globe.arcsData(arcsData)
          Globe.arcColor('color')
          Globe.arcDashLength(0.4)
          Globe.arcStroke(.4)
          Globe.arcDashGap(4)
          Globe.arcDashInitialGap((d) => d.initialGap)
          Globe.arcDashAnimateTime(1000);

          // Add new points
          let gData = endLocations.map(loc => ({
              lat: loc.lat,
              lng: -loc.lng,
              size: 20,
              color: 'white'
            }));
            Globe.htmlElementsData(gData)
            Globe.htmlElement(d => {
              const el = document.createElement('div');
              el.innerHTML = markerSvg;
              el.style.color = d.color;
              el.style.width = `${d.size}px`;
              return el;
          });

        } else {
          console.log('No data found.');
        }
      }, function(response) {
        console.error('Failed to get data from Sheets:', response.result.error.message);
      });
}

    

    // Setup renderer
    const renderers = [new THREE.WebGLRenderer({ antialias: true }),  new CSS2DRenderer()];

    renderers.forEach((r, idx) => {
      r.setSize(window.innerWidth, window.innerHeight);
      if (idx == 0) {
        r.setPixelRatio(window.devicePixelRatio);
      }
      if (idx > 0) {
        // overlay additional on top of main renderer
        r.domElement.style.position = 'absolute';
        r.domElement.style.top = '0px';
        r.domElement.style.pointerEvents = 'none';
      }
      document.getElementById('globeViz').appendChild(r.domElement);
    });

    // renderer.setSize(window.innerWidth, window.innerHeight);
    // renderer.setPixelRatio(window.devicePixelRatio);
    // document.getElementById('globeViz').appendChild(renderer.domElement);

    // Setup scene
    const scene = new THREE.Scene();
    scene.add(Globe);
    scene.add(new THREE.AmbientLight(0xcccccc, Math.PI));
    scene.add(new THREE.DirectionalLight(0xffffff, 0.6 * Math.PI));

    // Setup camera
    const camera = new THREE.PerspectiveCamera();
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    let altitudeHelper = 100

    const latitude = 34.05;
    const longitude = -118.24;
    // altitude in globe radius units
    let altitude = altitudeHelper / Globe.getGlobeRadius();
    let { x, y, z } = Globe.getCoords(latitude, longitude, altitude);
    camera.position.x = x;
    camera.position.y = y;
    camera.position.z = z

    // Add camera controls
    const latitudeInRadians = THREE.MathUtils.degToRad(latitude + 25);
    const tbControls = new OrbitControls( camera, renderers[0].domElement );
    // Lock Vertical rotation
    tbControls.maxPolarAngle = latitudeInRadians;
    tbControls.minPolarAngle = latitudeInRadians;


    // Update pov when camera moves
    Globe.setPointOfView(camera.position, Globe.position);
    tbControls.addEventListener('change', () => Globe.setPointOfView(camera.position, Globe.position));

      // Kick-off renderer
      handleClientLoad()
      let lastUpdateTime = 0; // Timestamp of the last update
      function animate() {
        requestAnimationFrame(animate);
        tbControls.update();
        
        // Get the current timestamp
        let currentTime = Date.now();
        
        // Update data every minute
        if (currentTime - lastUpdateTime > (endLocations.length * 1000)) {
          updateGlobeData();  // Call the update function
          lastUpdateTime = currentTime;  // Update the timestamp
        }
        
        renderers.forEach(renderer => renderer.render(scene, camera));
      }
      animate()
  </script>
  <script async defer src="https://accounts.google.com/gsi/client" onload="gisLoaded()"></script>
</body>